import React, { useState, useEffect } from 'react';
import { Event, Entity, Tag } from '../../types';
import TimelineCanvas from '../timeline/TimelineCanvas';
import './Timeline.css';

type TimelineType = 'world' | 'chapter';

interface TimelineProps {
  currentProjectId: number | null;
}

const Timeline: React.FC<TimelineProps> = ({ currentProjectId }) => {
  const [timelineEvents, setTimelineEvents] = useState<Event[]>([]);
  const [entities, setEntities] = useState<Entity[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [filteredEvents, setFilteredEvents] = useState<Event[]>([]);
  const [activeTimeline, setActiveTimeline] = useState<TimelineType>('world');
  const [filters, setFilters] = useState({
    entityType: 'all',
    tag: 'all',
    search: '',
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (currentProjectId) {
      loadData();
    }
  }, [currentProjectId]);

  useEffect(() => {
    filterEvents();
  }, [timelineEvents, filters, activeTimeline]);

  const loadData = async () => {
    if (!currentProjectId) return;
    
    try {
      setLoading(true);
      const [entitiesData, tagsData] = await Promise.all([
        window.electronAPI.entity.getAll(currentProjectId),
        window.electronAPI.tag.getAll(currentProjectId),
      ]);
      
      setEntities(entitiesData);
      setTags(tagsData);
      
      // ä»å®ä½“å’Œäº‹ä»¶ä¸­è‡ªåŠ¨æå–æ—¶é—´çº¿äº‹ä»¶
      const extractedEvents = extractTimelineEvents(entitiesData);
      setTimelineEvents(extractedEvents);
    } catch (error) {
      console.error('Failed to load timeline data:', error);
    } finally {
      setLoading(false);
    }
  };

  // ä»å®ä½“æ•°æ®ä¸­æå–æ—¶é—´çº¿äº‹ä»¶
  const extractTimelineEvents = (entitiesData: Entity[]): Event[] => {
    const events: Event[] = [];
    
    entitiesData.forEach(entity => {
      // ä»å®ä½“çš„è‡ªå®šä¹‰å­—æ®µä¸­æå–æ—¶é—´ä¿¡æ¯
      if (entity.customFields) {
        const { 
          birthDate, 
          deathDate, 
          creationDate, 
          discoveryDate, 
          foundingDate, 
          dissolutionDate,
          firstAppearance,
          lastAppearance,
          importantEvents 
        } = entity.customFields;

        // å¤„ç†å‡ºç”Ÿ/åˆ›å»º/å‘ç°/æˆç«‹æ—¥æœŸ
        const startDate = birthDate || creationDate || discoveryDate || foundingDate;
        if (startDate) {
          events.push({
            id: `entity-${entity.id}-start` as any,
            projectId: currentProjectId!,
            name: getStartEventName(entity),
            description: `${entity.name}çš„${getStartEventType(entity)}`,
            worldTime: startDate,
            relatedEntities: [entity.id!],
            tags: entity.tags || [],
            customFields: { 
              autoGenerated: true, 
              sourceEntity: entity.id,
              eventType: 'start'
            },
            createdAt: entity.createdAt,
            updatedAt: entity.updatedAt,
          });
        }

        // å¤„ç†æ­»äº¡/é”€æ¯/è§£æ•£æ—¥æœŸ
        const endDate = deathDate || dissolutionDate;
        if (endDate) {
          events.push({
            id: `entity-${entity.id}-end` as any,
            projectId: currentProjectId!,
            name: getEndEventName(entity),
            description: `${entity.name}çš„${getEndEventType(entity)}`,
            worldTime: endDate,
            relatedEntities: [entity.id!],
            tags: entity.tags || [],
            customFields: { 
              autoGenerated: true, 
              sourceEntity: entity.id,
              eventType: 'end'
            },
            createdAt: entity.createdAt,
            updatedAt: entity.updatedAt,
          });
        }

        // å¤„ç†é¦–æ¬¡/æœ€åå‡ºç°
        if (firstAppearance) {
          events.push({
            id: `entity-${entity.id}-first` as any,
            projectId: currentProjectId!,
            name: `${entity.name}é¦–æ¬¡å‡ºç°`,
            description: `${entity.name}åœ¨æ•…äº‹ä¸­é¦–æ¬¡å‡ºç°`,
            chapterNumber: typeof firstAppearance === 'number' ? firstAppearance : undefined,
            worldTime: typeof firstAppearance === 'string' ? firstAppearance : undefined,
            relatedEntities: [entity.id!],
            tags: entity.tags || [],
            customFields: { 
              autoGenerated: true, 
              sourceEntity: entity.id,
              eventType: 'firstAppearance'
            },
            createdAt: entity.createdAt,
            updatedAt: entity.updatedAt,
          });
        }

        if (lastAppearance) {
          events.push({
            id: `entity-${entity.id}-last` as any,
            projectId: currentProjectId!,
            name: `${entity.name}æœ€åå‡ºç°`,
            description: `${entity.name}åœ¨æ•…äº‹ä¸­æœ€åå‡ºç°`,
            chapterNumber: typeof lastAppearance === 'number' ? lastAppearance : undefined,
            worldTime: typeof lastAppearance === 'string' ? lastAppearance : undefined,
            relatedEntities: [entity.id!],
            tags: entity.tags || [],
            customFields: { 
              autoGenerated: true, 
              sourceEntity: entity.id,
              eventType: 'lastAppearance'
            },
            createdAt: entity.createdAt,
            updatedAt: entity.updatedAt,
          });
        }

        // å¤„ç†é‡è¦äº‹ä»¶åˆ—è¡¨
        if (importantEvents && Array.isArray(importantEvents)) {
          importantEvents.forEach((event, index) => {
            if (event.name && (event.worldTime || event.chapterNumber)) {
              events.push({
                id: `entity-${entity.id}-event-${index}` as any,
                projectId: currentProjectId!,
                name: event.name,
                description: event.description || `ä¸${entity.name}ç›¸å…³çš„é‡è¦äº‹ä»¶`,
                worldTime: event.worldTime,
                chapterNumber: event.chapterNumber,
                relatedEntities: [entity.id!],
                tags: entity.tags || [],
                customFields: { 
                  autoGenerated: true, 
                  sourceEntity: entity.id,
                  eventType: 'important',
                  eventIndex: index
                },
                createdAt: entity.createdAt,
                updatedAt: entity.updatedAt,
              });
            }
          });
        }
      }
    });

    return events;
  };

  const getStartEventName = (entity: Entity): string => {
    switch (entity.type) {
      case 'character': return `${entity.name}å‡ºç”Ÿ`;
      case 'item': return `${entity.name}è¢«åˆ›é€ `;
      case 'faction': return `${entity.name}æˆç«‹`;
      case 'event': return `${entity.name}å¼€å§‹`;
      default: return `${entity.name}å‡ºç°`;
    }
  };

  const getEndEventName = (entity: Entity): string => {
    switch (entity.type) {
      case 'character': return `${entity.name}æ­»äº¡`;
      case 'item': return `${entity.name}è¢«é”€æ¯`;
      case 'faction': return `${entity.name}è§£æ•£`;
      case 'event': return `${entity.name}ç»“æŸ`;
      default: return `${entity.name}æ¶ˆå¤±`;
    }
  };

  const getStartEventType = (entity: Entity): string => {
    switch (entity.type) {
      case 'character': return 'å‡ºç”Ÿ';
      case 'item': return 'åˆ›é€ ';
      case 'faction': return 'æˆç«‹';
      case 'event': return 'å¼€å§‹';
      default: return 'å‡ºç°';
    }
  };

  const getEndEventType = (entity: Entity): string => {
    switch (entity.type) {
      case 'character': return 'æ­»äº¡';
      case 'item': return 'é”€æ¯';
      case 'faction': return 'è§£æ•£';
      case 'event': return 'ç»“æŸ';
      default: return 'æ¶ˆå¤±';
    }
  };

  const filterEvents = () => {
    let filtered = timelineEvents;

    // æŒ‰æ—¶é—´çº¿ç±»å‹è¿‡æ»¤
    if (activeTimeline === 'world') {
      filtered = filtered.filter(event => event.worldTime);
    } else {
      filtered = filtered.filter(event => event.chapterNumber !== undefined);
    }

    // æŒ‰æœç´¢è¯è¿‡æ»¤
    if (filters.search) {
      filtered = filtered.filter(event =>
        event.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        (event.description && event.description.toLowerCase().includes(filters.search.toLowerCase()))
      );
    }

    // æŒ‰å®ä½“ç±»å‹è¿‡æ»¤
    if (filters.entityType !== 'all') {
      filtered = filtered.filter(event => {
        if (!event.relatedEntities || event.relatedEntities.length === 0) return false;
        return event.relatedEntities.some(entityId => {
          const entity = entities.find(e => e.id === entityId);
          return entity && entity.type === filters.entityType;
        });
      });
    }

    // æŒ‰æ ‡ç­¾è¿‡æ»¤
    if (filters.tag !== 'all') {
      filtered = filtered.filter(event =>
        event.tags && event.tags.includes(filters.tag)
      );
    }

    setFilteredEvents(filtered);
  };

  const handleFilterChange = (key: string, value: string) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
    }));
  };

  const handleRefresh = () => {
    loadData();
  };

  if (!currentProjectId) {
    return (
      <div className="view-container">
        <div className="empty-state">
          <div className="empty-state-icon">ğŸ“‹</div>
          <div className="empty-state-title">è¯·é€‰æ‹©é¡¹ç›®</div>
          <div className="empty-state-description">
            é€‰æ‹©ä¸€ä¸ªé¡¹ç›®æ¥æŸ¥çœ‹æ—¶é—´çº¿
          </div>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="view-container">
        <div className="loading">åŠ è½½ä¸­...</div>
      </div>
    );
  }

  return (
    <div className="view-container timeline-view">
      <div className="view-header">
        <h1 className="view-title">æ—¶é—´çº¿</h1>
        <p className="view-subtitle">ä»å®ä½“ä¿¡æ¯è‡ªåŠ¨ç”Ÿæˆçš„æ—¶é—´çº¿è§†å›¾</p>
        <div className="view-actions">
          <button className="btn btn-secondary" onClick={handleRefresh}>
            ğŸ”„ åˆ·æ–°æ—¶é—´çº¿
          </button>
        </div>
      </div>

      {/* æ—¶é—´çº¿åˆ‡æ¢å’Œç­›é€‰å™¨ */}
      <div className="timeline-controls">
        <div className="timeline-tabs">
          <button
            className={`timeline-tab ${activeTimeline === 'world' ? 'active' : ''}`}
            onClick={() => setActiveTimeline('world')}
          >
            ğŸŒ ä¸–ç•Œæ—¶é—´çº¿
          </button>
          <button
            className={`timeline-tab ${activeTimeline === 'chapter' ? 'active' : ''}`}
            onClick={() => setActiveTimeline('chapter')}
          >
            ğŸ“– ç« èŠ‚æ—¶é—´çº¿
          </button>
        </div>

        <div className="timeline-filters">
          <input
            type="text"
            className="input search-input"
            placeholder="æœç´¢äº‹ä»¶..."
            value={filters.search}
            onChange={(e) => handleFilterChange('search', e.target.value)}
          />
          
          <select
            className="input"
            value={filters.entityType}
            onChange={(e) => handleFilterChange('entityType', e.target.value)}
          >
            <option value="all">æ‰€æœ‰å®ä½“ç±»å‹</option>
            <option value="character">äººç‰©</option>
            <option value="item">ç‰©å“</option>
            <option value="faction">åŠ¿åŠ›</option>
            <option value="event">äº‹ä»¶</option>
          </select>

          <select
            className="input"
            value={filters.tag}
            onChange={(e) => handleFilterChange('tag', e.target.value)}
          >
            <option value="all">æ‰€æœ‰æ ‡ç­¾</option>
            {tags.map(tag => (
              <option key={tag.id} value={tag.name}>{tag.name}</option>
            ))}
          </select>
        </div>
      </div>

      {/* æ—¶é—´çº¿å¯è§†åŒ–åŒºåŸŸ */}
      <div className="timeline-content">
        {filteredEvents.length > 0 ? (
          <TimelineCanvas
            events={filteredEvents}
            entities={entities}
            tags={tags}
            timelineType={activeTimeline}
            onEventClick={() => {}} // è‡ªåŠ¨ç”Ÿæˆçš„äº‹ä»¶ä¸å¯ç¼–è¾‘
            onEventDelete={() => {}} // è‡ªåŠ¨ç”Ÿæˆçš„äº‹ä»¶ä¸å¯åˆ é™¤
          />
        ) : (
          <div className="empty-state">
            <div className="empty-state-icon">â°</div>
            <div className="empty-state-title">
              {activeTimeline === 'world' ? 'ä¸–ç•Œæ—¶é—´çº¿ä¸ºç©º' : 'ç« èŠ‚æ—¶é—´çº¿ä¸ºç©º'}
            </div>
            <div className="empty-state-description">
              {filters.search || filters.entityType !== 'all' || filters.tag !== 'all'
                ? 'æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„äº‹ä»¶'
                : `åœ¨å®ä½“ç®¡ç†ä¸­æ·»åŠ åŒ…å«æ—¶é—´ä¿¡æ¯çš„å®ä½“ï¼Œæ—¶é—´çº¿å°†è‡ªåŠ¨ç”Ÿæˆ`
              }
            </div>
            <div className="empty-state-help">
              <p>ğŸ’¡ æç¤ºï¼šåœ¨å®ä½“çš„è‡ªå®šä¹‰å­—æ®µä¸­æ·»åŠ ä»¥ä¸‹ä¿¡æ¯æ¥ç”Ÿæˆæ—¶é—´çº¿äº‹ä»¶ï¼š</p>
              <ul>
                <li><strong>äººç‰©ï¼š</strong>birthDateï¼ˆå‡ºç”Ÿæ—¥æœŸï¼‰ã€deathDateï¼ˆæ­»äº¡æ—¥æœŸï¼‰</li>
                <li><strong>ç‰©å“ï¼š</strong>creationDateï¼ˆåˆ›é€ æ—¥æœŸï¼‰ã€discoveryDateï¼ˆå‘ç°æ—¥æœŸï¼‰</li>
                <li><strong>åŠ¿åŠ›ï¼š</strong>foundingDateï¼ˆæˆç«‹æ—¥æœŸï¼‰ã€dissolutionDateï¼ˆè§£æ•£æ—¥æœŸï¼‰</li>
                <li><strong>é€šç”¨ï¼š</strong>firstAppearanceï¼ˆé¦–æ¬¡å‡ºç°ï¼‰ã€lastAppearanceï¼ˆæœ€åå‡ºç°ï¼‰</li>
                <li><strong>é‡è¦äº‹ä»¶ï¼š</strong>importantEventsï¼ˆé‡è¦äº‹ä»¶åˆ—è¡¨ï¼‰</li>
              </ul>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default Timeline;

